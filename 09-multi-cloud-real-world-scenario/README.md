# Case Study: Global Multi-Cloud High Availability üåçüå©Ô∏è

> **The Scenario**: An enterprise needs a resilient architecture where the primary application runs on AWS (East US), with a warm-standby Disaster Recovery (DR) site on Azure (West Europe), and a Global Traffic Management layer + Data Analytics hub on GCP.

---

## üèóÔ∏è The Architecture

| Cloud | Component | Role |
|-------|-----------|------|
| **AWS** | EKS + RDS (PostgreSQL) | Primary Region (USA) |
| **Azure** | AKS + Azure SQL | Secondary Region (EU Failover) |
| **GCP** | Cloud DNS + BigQuery | Global Traffic Steering & Data Warehouse |

---

## üöÄ Advanced Terraform Patterns Used

### 1. Multi-Cloud Provider Orchestration

We use **Provider Aliases** to manage three distinct cloud auth contexts in a single `apply`.

```hcl
# providers.tf
provider "aws" {
  region = "us-east-1"
}

provider "azurerm" {
  features {}
  subscription_id = var.azure_subscription_id
}

provider "google" {
  project = var.gcp_project_id
  region  = "us-central1"
}
```

### 2. Dependency Inversion across Clouds

How does GCP DNS know the Load Balancer IP from AWS or Azure? We use **Module Outputs** and **Complex Logic**.

```hcl
# main.tf

# 1. Provision AWS Primary
module "aws_primary" {
  source = "./modules/aws-stack"
  # ...
}

# 2. Provision Azure Secondary
module "azure_secondary" {
  source = "./modules/azure-stack"
  # ...
}

# 3. Global Traffic Steering (GCP)
resource "google_dns_record_set" "global_lb" {
  name         = "app.enterprise.com."
  type         = "A"
  ttl          = 300
  managed_zone = "my-zone"

  # Advanced: Weighted routing between AWS and Azure IPs
  routing_policy {
    wrr {
      weight = 0.8 # 80% to AWS
      rrdatas = [module.aws_primary.lb_ip]
    }
    wrr {
      weight = 0.2 # 20% to Azure (Warm Standby)
      rrdatas = [module.azure_secondary.lb_ip]
    }
  }
}
```

### 3. Data Sharding & Replication (Mocked Pattern)

In a real-world scenario, you need to replicate data. Terraform can orchestrate the **Cross-Cloud VPN or Interconnect**.

```hcl
# Hybrid Cloud VPN (AWS to Azure)
resource "aws_vpn_connection" "to_azure" {
  # ...
}

resource "azurerm_virtual_network_gateway_connection" "to_aws" {
  # ...
}
```

### 4. Logic: The "Cloud Switch"

Using a single variable to toggle the entire infrastructure state.

```hcl
variable "dr_mode" {
  type    = bool
  default = false
}

locals {
  # If DR mode is on, shift weights 100% to Azure
  aws_weight   = var.dr_mode ? 0 : 100
  azure_weight = var.dr_mode ? 100 : 0
}
```

---

## üß™ Deep Dive: State Management

In this scenario, a single `terraform.tfstate` file contains secrets and metadata for **all three clouds**.

**Principal Security Recommendation**:

- Use **Fine-grained IAM** for the CI/CD runner so it has "Least Privilege" in all three clouds.
- Use **Step-wise Apply**: Use `-target` if one cloud's API is currently failing, to avoid blocking the other two.

---

## üìÑ Key Takeaway

This isn't just about "Resource Creation". It's about **System Orchestration**. Terraform acts as the "Middle Manager" that ensures that GCP DNS is always updated with the dynamic IP generated by an Azure Load Balancer, while monitoring the health of an AWS EKS cluster.
